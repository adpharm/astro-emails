---
import { twMerge } from "tailwind-merge";
import {
  pop,
  extractFromClassList,
  extractValueFromPaddingClass,
  extractValueFromFontSizeClass,
  extractValueFromBorderRadiusClass,
  extractValueFromHeightClass,
} from "@/utils/utils";
import IfOutlook from "./IfOutlook.astro";
import IfNotOutlook from "./IfNotOutlook.astro";
import tailwindConfig from "tailwind.config";
import resolveConfig from "tailwindcss/resolveConfig";
import { type StandardPropertiesHyphen } from "csstype";
import { distStyles } from "@/assets/__styles-dist";

const tailwindConfigResolved = resolveConfig(tailwindConfig);

// Much of the outlook stuff was taken from https://buttons.cm/

interface Props {
  class?: string;
  href?: string;
}

const { class: className = "", href = "#" } = Astro.props;
const classList = className.split(" ").map((c) => c.trim());

const width = extractFromClassList(classList, "width");
const margin = extractFromClassList(classList, "margin");
const bgImage = extractFromClassList(classList, "bg-url");
const bgImageUrl = bgImage.replace(/^bg-\[url\(['"](.*)['"]\)\]/, "$1");
const bgColor = extractFromClassList(classList, "bg-color", "#ffffff");
const borderColor = extractFromClassList(classList, "border-color", "#ffffff");
// const padding = extractFromClassList(classList, "padding");
// const paddingValues = extractValueFromPaddingClass(padding);
const fontSize = extractFromClassList(classList, "font-size", tailwindConfigResolved.theme.fontSize.base || "16px");
const fontSizePx = extractValueFromFontSizeClass(fontSize);
// const height = extractFromClassList(classList, "height", `${fontSizePx + paddingValues.top + paddingValues.bottom}px`);
const height = extractFromClassList(classList, "height", `${fontSizePx}px`);
const heightPx = extractValueFromHeightClass(height);
const borderRadius = extractFromClassList(classList, "border-radius");
const borderRadiusPx = extractValueFromBorderRadiusClass(borderRadius);

const vRoundRectAttrs: Record<string, string> = {};

// fill
if (bgImageUrl.length > 0) {
  vRoundRectAttrs.fill = "t";
} else if (bgColor.length > 0) {
  vRoundRectAttrs.fillcolor = bgColor;
}

// stroke color
if (borderColor.length > 0) {
  vRoundRectAttrs.strokecolor = borderColor;
} else {
  vRoundRectAttrs.stroke = "f";
}

// arcsize (border-radius)

if (borderRadius.length > 0) {
  vRoundRectAttrs.arcsize = (borderRadiusPx / heightPx) * 100 + "%";
}

// const str = "bg-gray-300 bg-cover bg-[#454545]";
// findme("background-image", str); // => ""
// findme("background-color", str); // => "bg-gray-300"
// className
//   .split(" ")
//   .map((c) => c.trim())
//   .forEach((c) => {
//     console.log(c, distStyles[`.${c}`]);
//   });

// function cssPropertyToJsx(property: string): string {
//   return property.replace(/(-.)/g, (match) => match[1].toUpperCase());
// }

function findTailwindClassForCssSelector(selector: keyof StandardPropertiesHyphen, classStr: string) {
  return classStr
    .split(" ")
    .map((c) => c.trim())
    .findLast((c) => {
      const cssDeclarationObj = distStyles[`.${c}` as keyof typeof distStyles];
      return Object.keys(cssDeclarationObj).some((key) => key === selector);
    });
}

function findValueForCssSelector(selector: keyof StandardPropertiesHyphen, classStr: string) {
  const twClass = findTailwindClassForCssSelector(selector, classStr);

  if (!twClass) {
    return "";
  }

  const cssDeclarationObj = distStyles[`.${twClass}` as keyof typeof distStyles];
  for (const [key, val] of Object.entries(cssDeclarationObj)) {
    if (key === selector) {
      return `${val}`;
    }
  }

  return "";
}

console.log("\n");
const _bgImageUrl = findTailwindClassForCssSelector("background-image", className);
const _bgImageUrlValue = findValueForCssSelector("background-image", className);
console.log("bgImageUrl", _bgImageUrl, _bgImageUrlValue);
const paddingTop = findTailwindClassForCssSelector("padding-top", className);
const paddingTopValue = findValueForCssSelector("padding-top", className);
console.log("paddingTop", paddingTop, paddingTopValue);
const paddingBottom = findTailwindClassForCssSelector("padding-bottom", className);
const paddingBottomValue = findValueForCssSelector("padding-bottom", className);
console.log("paddingBottom", paddingBottom, paddingBottomValue);

// rest
const rest = [...classList, fontSize].join(" ");
---

<table class={twMerge(width, margin)}>
  <tbody>
    <tr>
      <td>
        <table class={twMerge(width)}>
          <tbody>
            <tr>
              <td>
                {/* Outlook */}
                <IfOutlook>
                  <v:roundrect
                    xmlns:v="urn:schemas-microsoft-com:vml"
                    xmlns:w="urn:schemas-microsoft-com:office:word"
                    href={href}
                    style="v-text-anchor:middle;"
                    class={twMerge(width, height)}
                    {...vRoundRectAttrs}
                  >
                    {bgImageUrl.length > 0 && <v:fill type="tile" src={bgImageUrl} color={bgColor} />}
                    <w:anchorlock></w:anchorlock>
                    <center class={twMerge(rest, fontSize)}>
                      <slot />
                    </center>
                  </v:roundrect>
                </IfOutlook>

                {/* Not Outlook */}
                <IfNotOutlook>
                  <a href={href} class={twMerge("inline-block", rest, width, height, bgImage, bgColor, borderRadius)}>
                    <slot />
                  </a>
                </IfNotOutlook>
              </td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
  </tbody>
</table>
